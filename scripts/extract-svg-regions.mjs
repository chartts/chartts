/**
 * Programmatic SVG path extractor for world map regions.
 *
 * Reads a world.svg file, parses all <path> elements, extracts country names
 * and path data, groups multi-path countries, and outputs a TypeScript file
 * with full-precision GeoRegion[] data.
 *
 * Usage: node scripts/extract-svg-regions.mjs <input.svg> <output.ts>
 */

import { readFileSync, writeFileSync } from 'fs'
import { resolve } from 'path'

const inputPath = process.argv[2]
const outputPath = process.argv[3]

if (!inputPath || !outputPath) {
  console.error('Usage: node scripts/extract-svg-regions.mjs <input.svg> <output.ts>')
  process.exit(1)
}

const svg = readFileSync(resolve(inputPath), 'utf-8')

// Map from country name -> array of path d strings
const regions = new Map()

// Match all <path ...> elements (self-closing or with closing tag)
// Two formats in the SVG:
//   1. <path d="..." id="XX" name="Country Name">
//   2. <path class="CountryName" d="...">
// Attributes can appear in any order.

const pathRegex = /<path\b([^>]*)>/gi
let match

while ((match = pathRegex.exec(svg)) !== null) {
  const attrs = match[1]

  // Extract d attribute
  const dMatch = attrs.match(/\bd\s*=\s*"([^"]*)"/)
  if (!dMatch) continue
  const d = dMatch[1].trim()
  if (!d) continue

  // Extract country name: prefer name="..." attribute, then class="..."
  let name = null

  const nameMatch = attrs.match(/\bname\s*=\s*"([^"]*)"/)
  if (nameMatch) {
    name = nameMatch[1].trim()
  }

  if (!name) {
    const classMatch = attrs.match(/\bclass\s*=\s*"([^"]*)"/)
    if (classMatch) {
      // class="Argentina" or class="United States" etc.
      name = classMatch[1].trim()
    }
  }

  if (!name) {
    // Try id as last resort (2-letter country code), but we prefer readable names
    const idMatch = attrs.match(/\bid\s*=\s*"([^"]*)"/)
    if (idMatch && idMatch[1].length > 1) {
      // Only use if it's not a numeric id (skip circle ids like "0", "1", "2")
      const id = idMatch[1].trim()
      if (!/^\d+$/.test(id)) {
        name = id  // Will be a 2-letter code like "AF"
      }
    }
  }

  if (!name) continue

  if (!regions.has(name)) {
    regions.set(name, [])
  }
  regions.get(name).push(d)
}

console.log(`Found ${regions.size} unique countries/regions`)

// Build a lookup from 2-letter codes to full names using id+name pairs
const codeToName = new Map()
const pathRegex2 = /<path\b([^>]*)>/gi
let match2
while ((match2 = pathRegex2.exec(svg)) !== null) {
  const attrs = match2[1]
  const idMatch = attrs.match(/\bid\s*=\s*"([^"]*)"/)
  const nameMatch = attrs.match(/\bname\s*=\s*"([^"]*)"/)
  if (idMatch && nameMatch) {
    codeToName.set(idMatch[1].trim(), nameMatch[1].trim())
  }
}

// Resolve 2-letter codes to full names where possible
const resolvedRegions = new Map()
for (const [name, paths] of regions) {
  const fullName = codeToName.get(name) || name
  if (resolvedRegions.has(fullName)) {
    // Merge paths
    resolvedRegions.get(fullName).push(...paths)
  } else {
    resolvedRegions.set(fullName, [...paths])
  }
}

console.log(`Resolved to ${resolvedRegions.size} named regions`)

// Sort regions alphabetically
const sorted = [...resolvedRegions.entries()].sort((a, b) => a[0].localeCompare(b[0]))

// For multi-path countries, join with space (SVG supports multiple M...Z subpaths)
const entries = sorted.map(([name, paths]) => {
  // Normalize: join multiple paths with a space separator
  const combinedPath = paths.join(' ')
  return { name, path: combinedPath }
})

// Generate TypeScript output
let ts = `/**
 * World map region paths â€” ALL ${entries.length} countries/territories.
 * Programmatically extracted from Simplemaps.com world.svg (MIT License).
 * Copyright (c) 2020 Pareto Software, LLC DBA Simplemaps.com
 *
 * Coordinate space: viewBox="0 0 2000 857"
 * Full precision preserved from source SVG.
 *
 * Generated by: scripts/extract-svg-regions.mjs
 * Source: world.svg
 */

import type { GeoRegion } from './geo-type'

export const WORLD_REGIONS: GeoRegion[] = [\n`

for (const entry of entries) {
  // Escape any single quotes in name
  const escapedName = entry.name.replace(/'/g, "\\'")
  // Use single quotes, preserve full path data
  ts += `  { name: '${escapedName}', path: '${entry.path}' },\n`
}

ts += `]\n`

writeFileSync(resolve(outputPath), ts, 'utf-8')
console.log(`Written ${entries.length} regions to ${outputPath}`)

// Print a summary of countries with multiple paths
let multiCount = 0
for (const [name, paths] of sorted) {
  if (paths.length > 1) {
    multiCount++
    if (multiCount <= 20) {
      console.log(`  Multi-path: ${name} (${paths.length} paths)`)
    }
  }
}
if (multiCount > 20) console.log(`  ... and ${multiCount - 20} more multi-path countries`)
console.log(`Total multi-path countries: ${multiCount}`)
