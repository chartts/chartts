import type { Renderer, RenderNode, RenderAttrs, ThemeConfig } from '../types'

/**
 * Canvas 2D Renderer.
 *
 * Converts the same RenderNode tree used by the SVG renderer into
 * Canvas 2D drawing commands. Designed for 1k–100k data points
 * where SVG DOM overhead becomes a bottleneck.
 *
 * Color resolution: Chart colors use `var(--token, #hex)` strings.
 * Canvas can't interpret CSS variables, so we extract the hex fallback.
 */

// ---------------------------------------------------------------------------
// Color utilities
// ---------------------------------------------------------------------------

/** Extract hex fallback from 'var(--token, #hex)' or return as-is */
function resolveColor(value: string | undefined, fallback: string = '#000'): string {
  if (!value) return fallback
  if (value === 'none' || value === 'transparent') return 'transparent'
  // url(#gradient-id) — handled separately
  if (value.startsWith('url(')) return value
  const match = value.match(/var\([^,]+,\s*([^)]+)\)/)
  return match ? match[1]!.trim() : value
}

/** Parse hex to rgba string */
function hexToRgba(hex: string, alpha: number): string {
  const h = hex.replace('#', '')
  const full = h.length === 3
    ? h[0]! + h[0]! + h[1]! + h[1]! + h[2]! + h[2]!
    : h
  const r = parseInt(full.substring(0, 2), 16)
  const g = parseInt(full.substring(2, 4), 16)
  const b = parseInt(full.substring(4, 6), 16)
  return `rgba(${r},${g},${b},${alpha})`
}

// ---------------------------------------------------------------------------
// Gradient cache (per-render)
// ---------------------------------------------------------------------------

/** Well-known gradient patterns generated by effects.ts */
function resolveGradientRef(
  id: string,
  colors: string[],
  ctx: CanvasRenderingContext2D,
  x: number, y: number, _w: number, h: number,
): CanvasGradient | string | null {
  // Area gradient: chartts-area-N
  const areaMatch = id.match(/^chartts-area-(\d+)$/)
  if (areaMatch) {
    const color = resolveColor(colors[parseInt(areaMatch[1]!)])
    const grad = ctx.createLinearGradient(x, y, x, y + h)
    grad.addColorStop(0, hexToRgba(color, 0.35))
    grad.addColorStop(1, hexToRgba(color, 0.02))
    return grad
  }

  // Bar gradient: chartts-bar-N
  const barMatch = id.match(/^chartts-bar-(\d+)$/)
  if (barMatch) {
    const color = resolveColor(colors[parseInt(barMatch[1]!)])
    const grad = ctx.createLinearGradient(x, y, x, y + h)
    grad.addColorStop(0, hexToRgba(color, 1))
    grad.addColorStop(1, hexToRgba(color, 0.75))
    return grad
  }

  // Pie gradient: chartts-pie-N
  const pieMatch = id.match(/^chartts-pie-(\d+)$/)
  if (pieMatch) {
    const color = resolveColor(colors[parseInt(pieMatch[1]!)])
    return color // Simplified — just use the color
  }

  // Point glow: chartts-pglow-N
  const glowMatch = id.match(/^chartts-pglow-(\d+)$/)
  if (glowMatch) {
    const color = resolveColor(colors[parseInt(glowMatch[1]!)])
    return hexToRgba(color, 0.4)
  }

  return null
}

/** Parse url(#id) and return the id */
function parseUrlRef(value: string): string | null {
  const match = value.match(/url\(#([^)]+)\)/)
  return match ? match[1]! : null
}

// ---------------------------------------------------------------------------
// Text alignment mapping
// ---------------------------------------------------------------------------

function mapTextAlign(anchor?: string): CanvasTextAlign {
  switch (anchor) {
    case 'middle': return 'center'
    case 'end': return 'right'
    default: return 'left'
  }
}

function mapTextBaseline(baseline?: string): CanvasTextBaseline {
  switch (baseline) {
    case 'middle':
    case 'central': return 'middle'
    case 'hanging': return 'hanging'
    default: return 'alphabetic'
  }
}

// ---------------------------------------------------------------------------
// Canvas Renderer
// ---------------------------------------------------------------------------

export interface CanvasRendererRoot {
  element: HTMLCanvasElement
  ctx: CanvasRenderingContext2D
  width: number
  height: number
  dpr: number
}

export function createCanvasRenderer(theme: ThemeConfig): Renderer {
  const colors = theme.colors

  // Clip path registry (id → Path2D)
  let clipPaths: Map<string, Path2D> = new Map()

  return {
    createRoot(target, width, height, attrs) {
      const canvas = document.createElement('canvas')
      const dpr = window.devicePixelRatio || 1
      canvas.width = width * dpr
      canvas.height = height * dpr
      canvas.style.width = `${width}px`
      canvas.style.height = `${height}px`
      canvas.style.display = 'block'

      if (attrs?.class) canvas.className = attrs.class
      if (attrs?.role) canvas.setAttribute('role', attrs.role)
      if (attrs?.ariaLabel) canvas.setAttribute('aria-label', attrs.ariaLabel)

      const ctx2d = canvas.getContext('2d')!
      ctx2d.scale(dpr, dpr)

      target.appendChild(canvas)

      // Store metadata on the root
      const root = { element: canvas } as unknown as { element: HTMLCanvasElement }
      ;(root as unknown as CanvasRendererRoot).ctx = ctx2d
      ;(root as unknown as CanvasRendererRoot).width = width
      ;(root as unknown as CanvasRendererRoot).height = height
      ;(root as unknown as CanvasRendererRoot).dpr = dpr

      return root as unknown as import('../types').RendererRoot
    },

    render(root, nodes) {
      const cr = root as unknown as CanvasRendererRoot
      clipPaths = new Map()
      cr.ctx.clearRect(0, 0, cr.width, cr.height)

      // First pass: collect clip path defs
      collectClipPaths(nodes)

      // Second pass: draw
      drawNodes(cr.ctx, nodes, cr.width, cr.height)
    },

    update(root, nodes) {
      this.render(root, nodes)
    },

    clear(root) {
      const cr = root as unknown as CanvasRendererRoot
      cr.ctx.clearRect(0, 0, cr.width, cr.height)
    },

    destroy(root) {
      root.element.remove()
    },
  }

  // -----------------------------------------------------------------------
  // Collect clip path definitions (first pass)
  // -----------------------------------------------------------------------

  function collectClipPaths(nodes: RenderNode[]): void {
    for (const node of nodes) {
      if (node.type === 'defs') {
        for (const child of node.children) {
          if (child.type === 'clipPath') {
            const path = new Path2D()
            for (const cp of child.children) {
              if (cp.type === 'rect') {
                path.rect(cp.x, cp.y, cp.width, cp.height)
              }
            }
            clipPaths.set(child.id, path)
          }
        }
      } else if (node.type === 'group') {
        collectClipPaths(node.children)
      }
    }
  }

  // -----------------------------------------------------------------------
  // Draw node tree
  // -----------------------------------------------------------------------

  function drawNodes(ctx: CanvasRenderingContext2D, nodes: RenderNode[], cw: number, ch: number): void {
    for (const node of nodes) {
      drawNode(ctx, node, cw, ch)
    }
  }

  function drawNode(ctx: CanvasRenderingContext2D, node: RenderNode, cw: number, ch: number): void {
    switch (node.type) {
      case 'group': {
        ctx.save()
        applyClip(ctx, node.attrs)
        applyTransform(ctx, node.attrs)
        applyOpacity(ctx, node.attrs)
        drawNodes(ctx, node.children, cw, ch)
        ctx.restore()
        break
      }

      case 'path': {
        const fill = resolveFill(ctx, node.attrs?.fill, 0, 0, cw, ch)
        const stroke = resolveColor(node.attrs?.stroke)
        const strokeWidth = node.attrs?.strokeWidth ?? 0
        const opacity = node.attrs?.opacity ?? 1
        const fillOpacity = node.attrs?.fillOpacity ?? 1

        ctx.save()
        applyClip(ctx, node.attrs)
        ctx.globalAlpha = opacity

        const p = new Path2D(node.d)

        // Default: paths have no fill (like SVG renderer)
        if (fill && fill !== 'transparent' && fill !== 'none' && node.attrs?.fill) {
          ctx.save()
          ctx.globalAlpha = opacity * fillOpacity
          if (typeof fill === 'object') {
            ctx.fillStyle = fill
          } else {
            ctx.fillStyle = fill
          }
          ctx.fill(p)
          ctx.restore()
        }

        if (stroke && stroke !== 'transparent' && stroke !== 'none' && strokeWidth > 0) {
          ctx.strokeStyle = typeof stroke === 'string' ? stroke : '#000'
          ctx.lineWidth = strokeWidth
          applyDash(ctx, node.attrs?.strokeDasharray)
          ctx.stroke(p)
          ctx.setLineDash([])
        }

        ctx.restore()
        break
      }

      case 'rect': {
        const fill = resolveFill(ctx, node.attrs?.fill, node.x, node.y, node.width, node.height)
        const stroke = resolveColor(node.attrs?.stroke)
        const strokeWidth = node.attrs?.strokeWidth ?? 0
        const opacity = node.attrs?.opacity ?? 1
        const fillOpacity = node.attrs?.fillOpacity ?? 1
        const rx = node.rx ?? 0

        ctx.save()
        applyClip(ctx, node.attrs)
        ctx.globalAlpha = opacity

        if (fill && fill !== 'transparent' && fill !== 'none') {
          ctx.save()
          ctx.globalAlpha = opacity * fillOpacity
          ctx.fillStyle = typeof fill === 'object' ? fill : fill
          if (rx > 0) {
            roundRect(ctx, node.x, node.y, node.width, node.height, rx)
            ctx.fill()
          } else {
            ctx.fillRect(node.x, node.y, node.width, node.height)
          }
          ctx.restore()
        }

        if (stroke && stroke !== 'transparent' && stroke !== 'none' && strokeWidth > 0) {
          ctx.strokeStyle = typeof stroke === 'string' ? stroke : '#000'
          ctx.lineWidth = strokeWidth
          applyDash(ctx, node.attrs?.strokeDasharray)
          if (rx > 0) {
            roundRect(ctx, node.x, node.y, node.width, node.height, rx)
            ctx.stroke()
          } else {
            ctx.strokeRect(node.x, node.y, node.width, node.height)
          }
          ctx.setLineDash([])
        }

        ctx.restore()
        break
      }

      case 'circle': {
        const fill = resolveFill(ctx, node.attrs?.fill, node.cx - node.r, node.cy - node.r, node.r * 2, node.r * 2)
        const stroke = resolveColor(node.attrs?.stroke)
        const strokeWidth = node.attrs?.strokeWidth ?? 0
        const opacity = node.attrs?.opacity ?? 1
        const fillOpacity = node.attrs?.fillOpacity ?? 1

        ctx.save()
        ctx.globalAlpha = opacity

        ctx.beginPath()
        ctx.arc(node.cx, node.cy, node.r, 0, Math.PI * 2)

        if (fill && fill !== 'transparent' && fill !== 'none') {
          ctx.save()
          ctx.globalAlpha = opacity * fillOpacity
          ctx.fillStyle = typeof fill === 'object' ? fill : fill
          ctx.fill()
          ctx.restore()
        }

        if (stroke && stroke !== 'transparent' && stroke !== 'none' && strokeWidth > 0) {
          ctx.strokeStyle = typeof stroke === 'string' ? stroke : '#000'
          ctx.lineWidth = strokeWidth
          ctx.stroke()
        }

        ctx.restore()
        break
      }

      case 'line': {
        const stroke = resolveColor(node.attrs?.stroke, '#000')
        const strokeWidth = node.attrs?.strokeWidth ?? 1
        const opacity = node.attrs?.opacity ?? 1

        if (stroke === 'transparent' || stroke === 'none') break

        ctx.save()
        ctx.globalAlpha = opacity
        ctx.strokeStyle = stroke
        ctx.lineWidth = strokeWidth
        applyDash(ctx, node.attrs?.strokeDasharray)
        ctx.beginPath()
        ctx.moveTo(node.x1, node.y1)
        ctx.lineTo(node.x2, node.y2)
        ctx.stroke()
        ctx.setLineDash([])
        ctx.restore()
        break
      }

      case 'text': {
        const fill = resolveColor(node.attrs?.fill, theme.textColor)
        const resolvedFill = resolveColor(fill)
        const opacity = node.attrs?.opacity ?? 1
        const fontSize = (node.attrs as Record<string, unknown>)?.fontSize as number ?? theme.fontSize
        const fontFamily = (node.attrs as Record<string, unknown>)?.fontFamily as string ?? theme.fontFamily
        const fontWeight = (node.attrs as Record<string, unknown>)?.fontWeight as string ?? 'normal'
        const textAnchor = (node.attrs as Record<string, unknown>)?.textAnchor as string | undefined
        const baseline = (node.attrs as Record<string, unknown>)?.dominantBaseline as string | undefined

        ctx.save()
        ctx.globalAlpha = opacity
        ctx.fillStyle = resolvedFill
        ctx.font = `${fontWeight} ${fontSize}px ${resolveColor(fontFamily)}`
        ctx.textAlign = mapTextAlign(textAnchor)
        ctx.textBaseline = mapTextBaseline(baseline)

        // Handle transform (rotation for y-axis label)
        applyTransform(ctx, node.attrs)

        ctx.fillText(node.content, node.x, node.y)
        ctx.restore()
        break
      }

      case 'defs':
      case 'clipPath':
        // Already processed in first pass
        break
    }
  }

  // -----------------------------------------------------------------------
  // Helpers
  // -----------------------------------------------------------------------

  function resolveFill(
    ctx: CanvasRenderingContext2D,
    fill: string | undefined,
    x: number, y: number, w: number, h: number,
  ): CanvasGradient | string {
    if (!fill) return 'transparent'
    const urlId = parseUrlRef(fill)
    if (urlId) {
      const grad = resolveGradientRef(urlId, colors as unknown as string[], ctx, x, y, w, h)
      return grad ?? resolveColor(fill)
    }
    return resolveColor(fill)
  }

  function applyClip(ctx: CanvasRenderingContext2D, attrs?: RenderAttrs): void {
    if (!attrs?.clipPath) return
    const clipId = attrs.clipPath
    const path = clipPaths.get(clipId)
    if (path) {
      ctx.clip(path)
    }
  }

  function applyTransform(ctx: CanvasRenderingContext2D, attrs?: RenderAttrs): void {
    if (!attrs?.transform) return
    const t = attrs.transform

    // translate(x, y)
    const translateMatch = t.match(/translate\(\s*([^,)]+)[,\s]+([^)]+)\)/)
    if (translateMatch) {
      ctx.translate(parseFloat(translateMatch[1]!), parseFloat(translateMatch[2]!))
    }

    // rotate(deg) or rotate(deg, cx, cy)
    const rotateMatch = t.match(/rotate\(\s*([^,)]+)(?:[,\s]+([^,)]+)[,\s]+([^)]+))?\)/)
    if (rotateMatch) {
      const angle = parseFloat(rotateMatch[1]!) * Math.PI / 180
      if (rotateMatch[2] && rotateMatch[3]) {
        const cx = parseFloat(rotateMatch[2])
        const cy = parseFloat(rotateMatch[3])
        ctx.translate(cx, cy)
        ctx.rotate(angle)
        ctx.translate(-cx, -cy)
      } else {
        ctx.rotate(angle)
      }
    }

    // scale(x, y)
    const scaleMatch = t.match(/scale\(\s*([^,)]+)(?:[,\s]+([^)]+))?\)/)
    if (scaleMatch) {
      const sx = parseFloat(scaleMatch[1]!)
      const sy = scaleMatch[2] ? parseFloat(scaleMatch[2]) : sx
      ctx.scale(sx, sy)
    }
  }

  function applyOpacity(ctx: CanvasRenderingContext2D, attrs?: RenderAttrs): void {
    if (attrs?.opacity != null) {
      ctx.globalAlpha *= attrs.opacity
    }
  }

  function applyDash(ctx: CanvasRenderingContext2D, dasharray?: string): void {
    if (!dasharray) return
    const segments = dasharray.split(/[\s,]+/).map(Number).filter(n => !isNaN(n))
    if (segments.length > 0) {
      ctx.setLineDash(segments)
    }
  }

  function roundRect(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, r: number): void {
    r = Math.min(r, w / 2, h / 2)
    ctx.beginPath()
    ctx.moveTo(x + r, y)
    ctx.lineTo(x + w - r, y)
    ctx.arcTo(x + w, y, x + w, y + r, r)
    ctx.lineTo(x + w, y + h - r)
    ctx.arcTo(x + w, y + h, x + w - r, y + h, r)
    ctx.lineTo(x + r, y + h)
    ctx.arcTo(x, y + h, x, y + h - r, r)
    ctx.lineTo(x, y + r)
    ctx.arcTo(x, y, x + r, y, r)
    ctx.closePath()
  }
}
